ЁЯФР Financial Integrity
Correction Plan тАФ Prediction Market Platform
Race Condition, Double-Spend & Wallet Integrity Fix (Vercel / Next.js)
тЪая╕П ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг ржирзЛржЯ: ржПржЗ plan-ржП existing codebase ржерзЗржХрзЗ ржХрзЛржирзЛ ржХрж┐ржЫрзБ delete ржХрж░рж╛ рж╣ржмрзЗ ржирж╛ред рж╢рзБржзрзБржорж╛рждрзНрж░ ржирждрзБржи SQL migration, ржирждрзБржи TypeScript functions, ржПржмржВ existing code-ржПрж░ gaps fill ржХрж░рж╛ рж╣ржмрзЗред рж╕ржорж╕рзНржд fix Vercel serverless ржПржмржВ Supabase-compatibleред
рж╕ржорж╕рзНржпрж╛рж░ ржкрзВрж░рзНржг ржЪрж┐рждрзНрж░ (Root Cause Analysis)
ржЖржкржирж╛рж░ codebase-ржП ржорзВрж▓ржд рзйржЯрж┐ ржЖрж▓рж╛ржжрж╛ layer-ржП рж╕ржорж╕рзНржпрж╛ рж░ржпрж╝рзЗржЫрзЗред ржПржЧрзБрж▓рзЛ individually ржХржо ржмрж┐ржкржЬрзНржЬржиржХ ржоржирзЗ рж╣рж▓рзЗржУ ржПржХрж╕рж╛ржерзЗ ржорж┐рж▓рзЗ real money loss ржПрж░ ржХрж╛рж░ржг рж╣рждрзЗ ржкрж╛рж░рзЗ:
#
File
рж╕ржорж╕рзНржпрж╛
Severity
Fix Step
1
orders/route.ts
TOCTOU Race: balance check ржУ freeze_funds ржПрж░ ржоржзрзНржпрзЗ gap ржЖржЫрзЗ
ЁЯФ┤ Critical
Step 2
2
010_wallet_system.sql
settle_trade_cash ржП FOR UPDATE lock ржирзЗржЗ
ЁЯФ┤ Critical
Step 1
3
010_wallet_system.sql
unfreeze_funds ржП row lock ржирзЗржЗ тАФ negative balance possible
ЁЯФ┤ Critical
Step 1
4
010_wallet_system.sql
wallet_transactions audit log table ржирзЗржЗ
ЁЯЯа High
Step 1
5
wallet/service.ts
processDeposit ржП idempotency ржирзЗржЗ тАФ same txid ржжрзБржмрж╛рж░ process рж╣ржмрзЗ
ЁЯФ┤ Critical
Step 3
6
useRealtimeBalance.ts
Realtime subscription user_id filter ржХрж░рзЗ ржирж╛ тАФ ржЕржирзНржпрзЗрж░ data ржжрзЗржЦрж╛ржирзЛрж░ risk
ЁЯФ┤ Critical
Step 4
7
useRealtimeBalance.ts
Optimistic locking / version check ржирзЗржЗ
ЁЯЯб Medium
Step 4
8
All
Idempotency keys table ржирзЗржЗ тАФ network retry рждрзЗ double execution
ЁЯФ┤ Critical
Step 5
рж╕ржмржЪрзЗржпрж╝рзЗ ржмрж┐ржкржЬрзНржЬржиржХ рж╣рж▓рзЛ TOCTOU (Time-Of-Check to Time-Of-Use) vulnerability тАФ ржпрзЗржЦрж╛ржирзЗ orders/route.ts ржП ржкрзНрж░ржержорзЗ balance check ржХрж░рж╛ рж╣ржпрж╝, рждрж╛рж░ржкрж░ freeze_funds call ржХрж░рж╛ рж╣ржпрж╝ред ржПржЗ ржжрзБржЗ operation ржПрж░ ржорж╛ржЭрзЗ millisecond-ржПрж░ gap-ржП ржжрзБржЯрзЛ concurrent request ржПржХржЗ balance ржжрзБржмрж╛рж░ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рждрзЗ ржкрж╛рж░рзЗред
STEP 1: Database Foundation Fix тАФ SQL Migration (011_integrity_fix.sql)
ржПржЗ step-ржП ржЖржорж░рж╛ ржирждрзБржи ржПржХржЯрж┐ migration file рждрзИрж░рж┐ ржХрж░ржм ржпрзЗржЯрж╛ existing 010_wallet_system.sql-ржПрж░ ржЙржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗред ржПржЦрж╛ржирзЗ рзкржЯрж┐ ржХрж╛ржЬ ржХрж░рж╛ рж╣ржмрзЗ:
рзз.ржХ тАФ wallet_transactions Audit Log Table ржпрзЛржЧ ржХрж░рж╛
Existing code-ржП wallet_balances ржЖржкржбрзЗржЯ рж╣ржпрж╝ ржХрж┐ржирзНрждрзБ ржХрзЛржирзЛ immutable transaction log рж░рж╛ржЦрж╛ рж╣ржпрж╝ ржирж╛ред ржПржЗ table ржпрзЛржЧ ржХрж░рж▓рзЗ ржбрзЗржЯрж╛рж░ ржЕржорж┐рж▓ рж╣рж▓рзЗ ржзрж░рж╛ ржкржбрж╝ржмрзЗ:
-- File: supabase/migrations/011_integrity_fix.sql
-- рзз. Audit log тАФ ржкрзНрж░рждрж┐ржЯрж┐ wallet change ржПржЦрж╛ржирзЗ record рж╣ржмрзЗ
CREATE TABLE IF NOT EXISTS wallet_transactions (
  id            UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id       UUID NOT NULL REFERENCES auth.users(id),
  amount        DECIMAL(36, 18) NOT NULL,
  type          TEXT NOT NULL CHECK (type IN (
                  'deposit','withdrawal','freeze',
                  'unfreeze','trade_settle','refund')),
  reference_id  TEXT,   -- txid / order_id / trade_id
  balance_before DECIMAL(36, 18) NOT NULL,
  balance_after  DECIMAL(36, 18) NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT NOW()
);
-- Fast lookups by user
CREATE INDEX IF NOT EXISTS idx_wallet_tx_user
  ON wallet_transactions(user_id, created_at DESC);
рзз.ржЦ тАФ Idempotency Keys Table ржпрзЛржЧ ржХрж░рж╛
Network timeout рж╣рж▓рзЗ client retry ржХрж░рзЗ тАФ ржПрждрзЗ same request ржжрзБржмрж╛рж░ execute рж╣ржУржпрж╝рж╛рж░ risk ржерж╛ржХрзЗред Idempotency key ржжрж┐ржпрж╝рзЗ database ржирж┐ржЬрзЗржЗ duplicate block ржХрж░ржмрзЗ:
-- рзи. Idempotency keys тАФ duplicate request block ржХрж░рж╛рж░ ржЬржирзНржп
CREATE TABLE IF NOT EXISTS idempotency_keys (
  key         TEXT PRIMARY KEY,
  user_id     UUID NOT NULL REFERENCES auth.users(id),
  operation   TEXT NOT NULL,
  result      JSONB,
  created_at  TIMESTAMPTZ DEFAULT NOW()
);
-- рзй ржжрж┐ржи ржкрж░ auto-expire (cron ржжрж┐ржпрж╝рзЗ ржмрж╛ Supabase pg_cron ржжрж┐ржпрж╝рзЗ)
CREATE INDEX IF NOT EXISTS idx_idem_user
  ON idempotency_keys(user_id, created_at);
рзз.ржЧ тАФ settle_trade_cash ржП Row Lock ржпрзЛржЧ ржХрж░рж╛ (CRITICAL)
тЪая╕П Critical Gap: Existing settle_trade_cash function-ржП buyer ржПржмржВ seller ржЙржнржпрж╝рзЗрж░ row lock ржХрж░рж╛ рж╣ржпрж╝ ржирж╛ред Concurrent trade settlement ржП ржПржЗ function ржжрзБржмрж╛рж░ ржЪрж▓рж▓рзЗ ржнрзБрж▓ balance рж╣рждрзЗ ржкрж╛рж░рзЗред ржирж┐ржЪрзЗрж░ replacement function-ржЯрж┐ existing function-ржПрж░ ржкрж░рж┐ржмрж░рзНрждрзЗ ржпрзЛржЧ ржХрж░рж╛ рж╣ржмрзЗ:
-- рзй. settle_trade_cash тАФ ржПржЦржи row lock рж╕рж╣, audit log рж╕рж╣
CREATE OR REPLACE FUNCTION settle_trade_cash(
  p_buyer_id  UUID,
  p_seller_id UUID,
  p_amount    DECIMAL,
  p_trade_id  TEXT DEFAULT NULL
)
RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_buyer_locked  DECIMAL;
  v_seller_bal    DECIMAL;
BEGIN
  -- Deadlock ржПржбрж╝рж╛рждрзЗ рж╕ржмрж╕ржоржпрж╝ ржЫрзЛржЯ user_id ржЖржЧрзЗ lock ржХрж░рждрзЗ рж╣ржмрзЗ
  IF p_buyer_id < p_seller_id THEN
    SELECT locked_balance INTO v_buyer_locked
      FROM wallets WHERE user_id = p_buyer_id FOR UPDATE;
    SELECT balance INTO v_seller_bal
      FROM wallets WHERE user_id = p_seller_id FOR UPDATE;
  ELSE
    SELECT balance INTO v_seller_bal
      FROM wallets WHERE user_id = p_seller_id FOR UPDATE;
    SELECT locked_balance INTO v_buyer_locked
      FROM wallets WHERE user_id = p_buyer_id FOR UPDATE;
  END IF;
  -- Buyer: locked_balance ржерзЗржХрзЗ ржХрж╛ржЯрж╛ (balance ржЖржЧрзЗржЗ freeze ржХрж░рж╛ ржЖржЫрзЗ)
  UPDATE wallets
    SET locked_balance = locked_balance - p_amount,
        updated_at = NOW()
    WHERE user_id = p_buyer_id;
  -- Seller: balance ржмрж╛ржбрж╝рж╛ржирзЛ
  UPDATE wallets
    SET balance = balance + p_amount,
        updated_at = NOW()
    WHERE user_id = p_seller_id;
  -- Audit log
  INSERT INTO wallet_transactions
    (user_id, amount, type, reference_id, balance_before, balance_after)
  VALUES
    (p_buyer_id,  -p_amount, 'trade_settle', p_trade_id,
     v_buyer_locked, v_buyer_locked - p_amount),
    (p_seller_id,  p_amount, 'trade_settle', p_trade_id,
     v_seller_bal,  v_seller_bal + p_amount);
END;
$$;
рзз.ржШ тАФ unfreeze_funds ржП Row Lock ржУ Validation ржпрзЛржЧ ржХрж░рж╛
Existing unfreeze_funds-ржП lock ржмрж╛ validation ржирзЗржЗред ржпржжрж┐ ржнрзБрж▓ржнрж╛ржмрзЗ ржжрзБржмрж╛рж░ call рж╣ржпрж╝ рждрж╛рж╣рж▓рзЗ locked_balance negative рж╣ржмрзЗред ржирж┐ржЪрзЗрж░ version ржЯрж┐ safer:
-- рзк. unfreeze_funds тАФ ржПржЦржи validation рж╕рж╣
CREATE OR REPLACE FUNCTION unfreeze_funds(
  p_user_id UUID,
  p_amount  DECIMAL
)
RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_locked DECIMAL;
BEGIN
  SELECT locked_balance INTO v_locked
    FROM wallets WHERE user_id = p_user_id FOR UPDATE;
  IF v_locked IS NULL OR v_locked < p_amount THEN
    RETURN FALSE;  -- ржкрж░рзНржпрж╛ржкрзНржд locked fund ржирзЗржЗ
  END IF;
  UPDATE wallets
    SET balance        = balance + p_amount,
        locked_balance = locked_balance - p_amount,
        updated_at     = NOW()
    WHERE user_id = p_user_id;
  RETURN TRUE;
END;
$$;
рзз.ржЩ тАФ Atomic Order + Freeze RPC (рж╕ржмржЪрзЗржпрж╝рзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг)
ржПржЯрж┐ рж╣рж▓рзЛ TOCTOU vulnerability-рж░ ржорзВрж▓ рж╕ржорж╛ржзрж╛ржиред ржПржХржЯрж┐ single RPC call-ржПржЗ balance validation ржПржмржВ fund freeze ржПржХрж╕рж╛ржерзЗ atomic ржнрж╛ржмрзЗ ржХрж░рж╛ рж╣ржмрзЗ, ржпрж╛рждрзЗ check ржПржмржВ freeze ржПрж░ ржорж╛ржЭрзЗ ржХрзЛржирзЛ gap ржирж╛ ржерж╛ржХрзЗ:
-- рзл. place_order_atomic тАФ balance check + freeze ржПржХржЯрж┐ transaction ржП
CREATE OR REPLACE FUNCTION place_order_atomic(
  p_user_id        UUID,
  p_market_id      UUID,
  p_side           TEXT,
  p_outcome        TEXT,
  p_price          DECIMAL,
  p_quantity       DECIMAL,
  p_order_type     TEXT DEFAULT 'limit',
  p_idempotency_key TEXT DEFAULT NULL
)
RETURNS JSONB LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_balance     DECIMAL;
  v_required    DECIMAL;
  v_order_id    UUID;
  v_existing    JSONB;
BEGIN
  -- Idempotency check: ржЖржЧрзЗ ржПржЗ key ржжрж┐ржпрж╝рзЗ ржХрзЛржирзЛ order рж╣ржпрж╝рзЗржЫрж┐рж▓ ржХрж┐ржирж╛
  IF p_idempotency_key IS NOT NULL THEN
    SELECT result INTO v_existing FROM idempotency_keys
      WHERE key = p_idempotency_key AND user_id = p_user_id;
    IF FOUND THEN RETURN v_existing; END IF;
  END IF;
  v_required := p_price * p_quantity;
  -- Row-level lock ржирж┐ржпрж╝рзЗ balance check
  SELECT balance INTO v_balance
    FROM wallets WHERE user_id = p_user_id FOR UPDATE;
  IF v_balance IS NULL OR v_balance < v_required THEN
    RETURN jsonb_build_object('error', 'Insufficient balance');
  END IF;
  -- Fund freeze (ржПржЦржи ржХрзЛржирзЛ race ржирзЗржЗ, row already locked)
  IF p_side = 'buy' THEN
    UPDATE wallets
      SET balance        = balance - v_required,
          locked_balance = locked_balance + v_required,
          updated_at     = NOW()
      WHERE user_id = p_user_id;
  END IF;
  -- Order insert
  INSERT INTO orders
    (user_id, market_id, side, outcome, order_type,
     price, quantity, filled_quantity, status)
  VALUES
    (p_user_id, p_market_id, p_side, p_outcome, p_order_type,
     p_price, p_quantity, 0, 'open')
  RETURNING id INTO v_order_id;
  -- Idempotency key save
  IF p_idempotency_key IS NOT NULL THEN
    INSERT INTO idempotency_keys (key, user_id, operation, result)
    VALUES (p_idempotency_key, p_user_id, 'place_order',
      jsonb_build_object('success', true, 'order_id', v_order_id))
    ON CONFLICT (key) DO NOTHING;
  END IF;
  RETURN jsonb_build_object('success', true, 'order_id', v_order_id);
END;
$$;
тЬЕ Step 1 Complete: Migration file рждрзИрж░рж┐ рж╣рж▓рзЗ ржПржЯрж┐ supabase/migrations/011_integrity_fix.sql рж╣рж┐рж╕рзЗржмрзЗ save ржХрж░рзБржи ржПржмржВ supabase db push ржжрж┐ржпрж╝рзЗ apply ржХрж░рзБржиред
STEP 2: orders/route.ts тАФ TOCTOU Fix (Atomic RPC ржмрзНржпржмрж╣рж╛рж░)
Existing orders/route.ts-ржП POST handler-ржП ржкрзНрж░ржержорзЗ balance check рж╣ржпрж╝, рждрж╛рж░ржкрж░ ржЖрж▓рж╛ржжрж╛ржнрж╛ржмрзЗ freeze_funds call рж╣ржпрж╝ред ржПржЗ рзиржЯрж┐ operation ржПрж░ ржорж╛ржЭрзЗ race window ржЖржЫрзЗред ржПржЦржи ржирждрзБржи place_order_atomic RPC ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржкрзБрж░рзЛ flow single call ржП ржХрж░рж╛ рж╣ржмрзЗред
Existing file-ржП balance check block ржУ freeze_funds block replace ржХрж░рждрзЗ рж╣ржмрзЗред ржмрж╛ржХрж┐ рж╕ржм code (validation, activity log, cache invalidation) ржЕржкрж░рж┐ржмрж░рзНрждрж┐ржд ржерж╛ржХржмрзЗред
Existing Code тАФ ржкрж░рж┐ржмрж░рзНрждрж┐ржд рж╣ржмрзЗ (рж▓рж╛рж▓ section)
// тЭМ BEFORE тАФ Race condition vulnerable (orders/route.ts)
// ржПржЗ ржжрзБржЯрзЛ separate call ржПрж░ ржорж╛ржЭрзЗ gap ржЖржЫрзЗ:
const { data: wallet } = await supabase
  .from('wallets').select('*')
  .eq('user_id', user.id).single();
if (!wallet || wallet.balance < requiredFunds) { ... }
// ржПржЦрж╛ржирзЗ ржЕржирзНржп request ржПрж╕рзЗ balance ржирж┐ржпрж╝рзЗ ржпрзЗрждрзЗ ржкрж╛рж░рзЗ!
if (side === 'buy') {
  const { error: lockError } = await supabase.rpc('freeze_funds', {
    p_user_id: user.id, p_amount: requiredFunds
  });
}
const { data: order, error: orderError } = await supabase
  .from('orders').insert({ ... }).select().single();
Fixed Code тАФ Atomic RPC ржмрзНржпржмрж╣рж╛рж░ (рж╕ржмрзБржЬ section)
Existing file-ржПрж░ POST handler-ржП // Check the user's wallet ржерзЗржХрзЗ // Trigger the matching engine ржкрж░рзНржпржирзНржд ржЕржВрж╢ржЯрж┐ ржирж┐ржЪрзЗрж░ code ржжрж┐ржпрж╝рзЗ replace ржХрж░рзБржи:
// тЬЕ AFTER тАФ apps/web/src/app/api/orders/route.ts ржП ржПржЗ section replace ржХрж░рзБржи
// (Existing validation, auth, activity log code ржЕржкрж░рж┐ржмрж░рзНрждрж┐ржд ржерж╛ржХржмрзЗ)
// Idempotency key тАФ client ржерзЗржХрзЗ ржкрж╛ржарж╛ржирзЛ, ржирж╛ рж╣рж▓рзЗ generate ржХрж░рзБржи
const idempotencyKey = body.idempotency_key ||
  `order-${user.id}-${Date.now()}`;
// тЬЕ SINGLE ATOMIC RPC тАФ balance check + freeze + order insert
// ржПржЦржи ржЖрж░ ржХрзЛржирзЛ race condition ржирзЗржЗ
const { data: result, error: atomicError } = await supabase
  .rpc('place_order_atomic', {
    p_user_id:         user.id,
    p_market_id:       market_id,
    p_side:            side,
    p_outcome:         outcome,
    p_price:           price,
    p_quantity:        quantity,
    p_order_type:      order_type,
    p_idempotency_key: idempotencyKey,
  });
if (atomicError || result?.error) {
  return NextResponse.json(
    { error: result?.error || 'Order placement failed' },
    { status: result?.error === 'Insufficient balance' ? 400 : 500 }
  );
}
const orderId = result.order_id;
// Trigger matching engine (existing code ржЕржкрж░рж┐ржмрж░рзНрждрж┐ржд)
await supabase.rpc('match_order', { p_order_id: orderId });
ЁЯУМ Note: Existing freeze_funds, unfreeze_funds RPC call ржПржмржВ manual order insert тАФ рж╕ржм replace рж╣ржпрж╝рзЗ ржпрж╛ржмрзЗ ржПржЗ ржПржХржЯрж┐ atomic call ржжрж┐ржпрж╝рзЗред Rollback ржПржЦржи database-level ржП handle рж╣ржмрзЗред
STEP 3: wallet/service.ts тАФ Deposit Idempotency Fix
Existing PaymentVerificationService.processDeposit method-ржП ржПржХржЗ txid ржжрж┐ржпрж╝рзЗ ржжрзБржмрж╛рж░ call ржХрж░рж▓рзЗ ржмрзНржпрж╛рж▓рзЗржирзНрж╕ ржжрзБржмрж╛рж░ ржмрж╛ржбрж╝ржмрзЗред ржХрж╛рж░ржг process_deposit_tx RPC-рждрзЗ duplicate check ржирзЗржЗред
Database-ржП process_deposit_tx RPC Update ржХрж░рзБржи
Supabase-ржП ржПржЗ ржирждрзБржи function ржпрзЛржЧ ржХрж░рзБржи ржпрж╛ 011_integrity_fix.sql-ржПрж░ idempotency_keys table ржмрзНржпржмрж╣рж╛рж░ ржХрж░ржмрзЗ:
-- supabase/migrations/011_integrity_fix.sql ржП ржпрзЛржЧ ржХрж░рзБржи
CREATE OR REPLACE FUNCTION process_deposit_tx(
  p_user_id UUID,
  p_amount  DECIMAL,
  p_txid    TEXT
)
RETURNS BOOLEAN LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE
  v_balance DECIMAL;
BEGIN
  -- Idempotency: ржПржХржЗ txid ржЖржЧрзЗ process рж╣ржпрж╝рзЗржЫрзЗ ржХрж┐ржирж╛
  IF EXISTS (
    SELECT 1 FROM idempotency_keys
    WHERE key = 'deposit-' || p_txid
  ) THEN
    RETURN TRUE;  -- Already processed, safe to return
  END IF;
  -- Balance lock ржирж┐ржпрж╝рзЗ update
  SELECT balance INTO v_balance
    FROM wallets WHERE user_id = p_user_id FOR UPDATE;
  UPDATE wallets
    SET balance    = balance + p_amount,
        updated_at = NOW()
    WHERE user_id = p_user_id;
  -- Audit log
  INSERT INTO wallet_transactions
    (user_id, amount, type, reference_id, balance_before, balance_after)
  VALUES
    (p_user_id, p_amount, 'deposit', p_txid,
     v_balance, v_balance + p_amount);
  -- Idempotency key save
  INSERT INTO idempotency_keys (key, user_id, operation, result)
  VALUES ('deposit-' || p_txid, p_user_id, 'deposit',
    jsonb_build_object('amount', p_amount))
  ON CONFLICT (key) DO NOTHING;
  RETURN TRUE;
END;
$$;
тЬЕ wallet/service.ts ржкрж░рж┐ржмрж░рзНрждржи: TypeScript service.ts file-ржП ржХрзЛржирзЛ ржкрж░рж┐ржмрж░рзНрждржи ржжрж░ржХрж╛рж░ ржирзЗржЗред processDeposit method ржЯрж┐ ржПржЦржирзЛ supabase.rpc('process_deposit_tx', ...) call ржХрж░ржмрзЗ тАФ рж╢рзБржзрзБ database function ржЯрж┐ ржПржЦржи idempotentред
STEP 4: useRealtimeBalance.ts тАФ Security & Optimistic Lock Fix
ЁЯФ┤ Security Bug: Existing subscription-ржП table: 'wallets' filter ржХрж░рж╛ рж╣ржпрж╝ ржХрж┐ржирзНрждрзБ user_id filter ржирзЗржЗред ржПрж░ ржорж╛ржирзЗ рж╣рж▓рзЛ ржпрзЗржХрзЛржирзЛ user-ржПрж░ wallet update рж╣рж▓рзЗ рж╕ржмрж╛ржЗ рж╕рзЗржЗ data ржкрж╛ржмрзЗред ржирж┐ржЪрзЗрж░ ржкрж░рж┐ржмрж░рзНрждржиржЧрзБрж▓рзЛ existing useRealtimeBalance.ts-ржП ржХрж░рждрзЗ рж╣ржмрзЗ:
Security Fix: User-ID Filter ржпрзЛржЧ ржХрж░рзБржи
// apps/web/src/hooks/useRealtimeBalance.ts
// EXISTING useEffect ржПрж░ channel subscription ржЕржВрж╢ replace ржХрж░рзБржи:
useEffect(() => {
  let userId: string | null = null;
  const init = async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;
    userId = user.id;
    await fetchBalance();
    // тЬЕ FIX: user_id ржжрж┐ржпрж╝рзЗ filter тАФ ржЕржирзНржпрзЗрж░ data ржЖрж╕ржмрзЗ ржирж╛
    const channel = supabase
      .channel(`wallet:${user.id}`)   // unique channel per user
      .on('postgres_changes', {
        event:  '*',
        schema: 'public',
        table:  'wallets',
        filter: `user_id=eq.${user.id}`,  // тЖР ржПржЯрж╛ржЗ ржорзВрж▓ fix
      },
      (payload: any) => {
        if (payload.new) {
          // тЬЕ Optimistic lock: server data ржпржжрж┐ ржЖрж░рзЛ ржирждрзБржи рж╣ржпрж╝ рждрж╛рж╣рж▓рзЗржЗ update
          setBalance(prev => {
            const incoming = payload.new as WalletBalance;
            if (!prev) return incoming;
            // updated_at compare ржХрж░рзЗ stale update ignore ржХрж░рзБржи
            const prevTime = (prev as any).updated_at || '';
            const newTime  = (incoming as any).updated_at || '';
            if (newTime >= prevTime) {
              setSyncing(false);
              return incoming;
            }
            return prev;  // ржкрзБрж░ржирзЛ data ignore
          });
        }
      })
      .subscribe();
    return () => { supabase.removeChannel(channel); };
  };
  const cleanup = init();
  return () => { cleanup.then(fn => fn && fn()); };
}, [fetchBalance, supabase]);
Syncing State ржпрзЛржЧ ржХрж░рзБржи
Existing hook-ржПрж░ useState section-ржП рж╢рзБржзрзБ ржПржХржЯрж┐ ржирждрзБржи state ржпрзЛржЧ ржХрж░рзБржи ржПржмржВ return value-ржП include ржХрж░рзБржи:
// Existing useState ржПрж░ ржкрж░рзЗ ржПржЯрж┐ ржпрзЛржЧ ржХрж░рзБржи:
const [syncing, setSyncing] = useState(false);
// Order place ржХрж░рж╛рж░ ржЖржЧрзЗ call ржХрж░рзБржи:
// setSyncing(true) тАФ UI рждрзЗ 'Syncing...' ржжрзЗржЦрж╛ржмрзЗ
// Existing return statement update ржХрж░рзБржи:
return {
  balance,
  loading,
  error,
  syncing,           // тЖР ржирждрзБржи
  setSyncing,        // тЖР ржирждрзБржи (order place button ржерзЗржХрзЗ call ржХрж░рзБржи)
  refreshBalance,
  availableBalance: (balance?.usdt_balance || 0) - (balance?.locked_usdt || 0),
};
STEP 5: Frontend тАФ Idempotency Key Integration (Order Placement)
Client side ржерзЗржХрзЗ order place ржХрж░рж╛рж░ рж╕ржоржпрж╝ ржкрзНрж░рждрж┐ржЯрж┐ request-ржП ржПржХржЯрж┐ unique idempotency key ржкрж╛ржарж╛рждрзЗ рж╣ржмрзЗред ржПрждрзЗ network retry ржмрж╛ double-click ржПрж░ ржХрзНрж╖рзЗрждрзНрж░рзЗ server same order ржжрзБржмрж╛рж░ create ржХрж░ржмрзЗ ржирж╛ред
Order Placement Component-ржП Key Generation
ржЖржкржирж╛рж░ trade form ржмрж╛ order placement component ржпрзЗржЦрж╛ржирзЗржЗ ржерж╛ржХрзБржХ, рж╕рзЗржЦрж╛ржирзЗ ржирж┐ржЪрзЗрж░ pattern follow ржХрж░рзБржи:
// apps/web/src/components/trading/OrderForm.tsx (ржмрж╛ equivalent)
// Existing import ржПрж░ рж╕рж╛ржерзЗ ржпрзЛржЧ ржХрж░рзБржи:
import { v4 as uuidv4 } from 'uuid';
// Existing state ржПрж░ ржкрж╛рж╢рзЗ:
const [idempotencyKey, setIdempotencyKey] = useState(uuidv4());
// Order submit handler (existing handleSubmit function ржП ржпрзЛржЧ ржХрж░рзБржи):
const handleSubmit = async () => {
  setSyncing(true);  // useRealtimeBalance ржерзЗржХрзЗ
  const response = await fetch('/api/orders', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      market_id, side, outcome, price, quantity,
      idempotency_key: idempotencyKey,  // тЖР ржирждрзБржи field ржпрзЛржЧ ржХрж░рзБржи
    }),
  });
  if (response.ok) {
    // Success рж╣рж▓рзЗ ржирждрзБржи key generate ржХрж░рзБржи ржкрж░рзЗрж░ order ржПрж░ ржЬржирзНржп
    setIdempotencyKey(uuidv4());
  }
  // Error рж╣рж▓рзЗ same key рж░рж╛ржЦрзБржи тАФ retry safe рж╣ржмрзЗ
};
STEP 6: Concurrency Stress Test тАФ Verification
Fix ржХрж░рж╛рж░ ржкрж░ verify ржХрж░рждрзЗ рж╣ржмрзЗ ржпрзЗ race condition рж╕рждрзНржпрж┐ржЗ ржарж┐ржХ рж╣ржпрж╝рзЗржЫрзЗред ржирж┐ржЪрзЗрж░ test script ржЯрж┐ ржПржХржЗ ржУржпрж╝рж╛рж▓рзЗржЯ ржерзЗржХрзЗ рззрзжржЯрж┐ concurrent request ржкрж╛ржарж╛ржмрзЗ:
// scripts/stress-test-wallet.ts
// npm install @supabase/supabase-js тАФ already installed
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const SUPABASE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
async function stressTestWallet(userId: string) {
  const { createClient } = await import('@supabase/supabase-js');
  const sb = createClient(SUPABASE_URL, SUPABASE_KEY);
  // Initial balance check
  const { data: before } = await sb.from('wallets')
    .select('balance').eq('user_id', userId).single();
  console.log('Before:', before?.balance);
  // рззрзжржЯрж┐ concurrent freeze request (рзлрзж ржЯрж╛ржХрж╛ ржХрж░рзЗ)
  const requests = Array(10).fill(null).map((_, i) =>
    sb.rpc('freeze_funds', { p_user_id: userId, p_amount: 50 })
      .then(r => ({ index: i, success: !r.error, data: r.data }))
  );
  const results = await Promise.all(requests);
  const successCount = results.filter(r => r.success && r.data).length;
  console.log(`Successful freezes: ${successCount}/10`);
  const { data: after } = await sb.from('wallets')
    .select('balance, locked_balance').eq('user_id', userId).single();
  console.log('After balance:', after?.balance);
  console.log('After locked:', after?.locked_balance);
  // тЬЕ Expected: balance + locked_balance === initial balance
  const intact = parseFloat(before?.balance) ===
    parseFloat(after?.balance) + parseFloat(after?.locked_balance);
  console.log(intact ? 'тЬЕ Financial integrity maintained' :
                       'тЭМ INTEGRITY VIOLATION DETECTED');
}
STEP 7: Deployment Checklist тАФ Vercel + Supabase
рж╕ржорж╕рзНржд fix apply ржХрж░рж╛рж░ ржкрж░ ржирж┐ржЪрзЗрж░ deployment steps follow ржХрж░рзБржиред Vercel serverless environment-ржП ржХрзЛржирзЛ connection pooling issue ржирж╛ рж╣ржпрж╝ рж╕рзЗржЬржирзНржп ржмрж┐рж╢рзЗрж╖ рж╕рждрж░рзНржХрждрж╛ рж░рж╛ржЦрж╛ рж╣ржпрж╝рзЗржЫрзЗ:
# рзз. Migration apply ржХрж░рзБржи
supabase db push
# рзи. Migration рж╕ржлрж▓ рж╣ржпрж╝рзЗржЫрзЗ ржХрж┐ржирж╛ verify ржХрж░рзБржи
supabase db diff
# рзй. RPC functions exist ржХрж░рзЗ ржХрж┐ржирж╛ test ржХрж░рзБржи
supabase functions list
# рзк. uuid package add ржХрж░рзБржи (idempotency key generation)
npm install uuid
npm install --save-dev @types/uuid
# рзл. Vercel ржП deploy
vercel --prod
ЁЯФТ Supabase RLS Policy: wallets table-ржП Row Level Security (RLS) ensure ржХрж░рзБржи ржпрж╛рждрзЗ authenticated user рж╢рзБржзрзБ ржирж┐ржЬрзЗрж░ row read/write ржХрж░рждрзЗ ржкрж╛рж░рзЗ: ALTER TABLE wallets ENABLE ROW LEVEL SECURITY; тАФ ржПржмржВ appropriate policy add ржХрж░рзБржиред
рж╕ржорзНржкрзВрж░рзНржг ржкрж░рж┐ржмрж░рзНрждржирзЗрж░ Summary
File/Location
ржкрж░рж┐ржмрж░рзНрждржирзЗрж░ ржзрж░ржи
ржХрзА ржпрзЛржЧ/ржкрж░рж┐ржмрж░рзНрждржи рж╣рж▓рзЛ
migrations/011_integrity_fix.sql
ржирждрзБржи file рждрзИрж░рж┐
wallet_transactions, idempotency_keys tables; settle_trade_cash, unfreeze_funds, process_deposit_tx, place_order_atomic functions
apps/web/src/app/api/orders/route.ts
Existing POST handler update
Balance check + freeze_funds тЖТ place_order_atomic single RPC; idempotency_key support
apps/web/src/hooks/useRealtimeBalance.ts
Existing hook update
user_id filter ржпрзЛржЧ; syncing state; optimistic lock comparison
apps/web/src/components/trading/OrderForm.tsx
Client code addition
idempotency_key generation ржПржмржВ submission
scripts/stress-test-wallet.ts
ржирждрзБржи test script
Concurrent request test for race condition verification
ржПржЗ plan рж╕ржорзНржкрзВрж░рзНржгржнрж╛ржмрзЗ follow ржХрж░рж▓рзЗ ржЖржкржирж╛рж░ prediction market platform-ржП financial double-spending, race conditions, ржПржмржВ duplicate deposit рж╕ржорж╕рзНржпрж╛ржЧрзБрж▓рзЛ ржжрзВрж░ рж╣ржмрзЗред рж╕ржмржЪрзЗржпрж╝рзЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржг рж╣рж▓рзЛ place_order_atomic тАФ ржПржЗ ржПржХржЯрж┐ change-ржЗ TOCTOU vulnerability рж╕ржорзНржкрзВрж░рзНржг eliminate ржХрж░рзЗ ржПржмржВ Bangladeshi ржЯрж╛ржХрж╛ ржУ USDT ржЙржнржпрж╝рзЗрж░ ржЬржирзНржп safeред